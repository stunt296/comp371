FINAL PROJECT COMP 371: Walk Through a Procedurally Modeled World
# Amin Kadawala
# Alexander Rainbow
# Erin Rainville 
* The terrain is generated by going through a 2D float array (a heightmap) that holds the <x,z> positions of the map and the y value for the height of the cubes It calls glDrawArrays for every face that is visible, aka it renders all the faces of the cubes that are above the height of the neighboring cubes.
* The different texture is illustrated by changing the color of the cement texture from lab 04.
* The water is generated by adding a blue, translucent top face above every top face that is below the designated water level.
* The trees are generated by going over the heightmap, checking if the <x,y,z> is above water level, if yes then it calculates a 1% chance of placing a tree in that area, and if it is true then it checks to make sure the tree placement would not collide with another tree’s placement. If this is all true, it adds the position to a position vector. In the main while loop, it draws the trees based on the position vector.

# Henry Li
* Setup: Appropriate keys were given to the camera movement to facilitate navigation. Alpha variable and a normal introduced to cube model. Initial code cleaned up a bit and irrelevant content removed.
* Sky box: Set up the scene. Textured cubes are being used to create the walls and floor of a larger environment (sky box). The initial color is set to blue giving the scene a consistent appearance no matter which texture is used.
* Basic Tree models: Textured cubes are being used to create the trunk and the leaves of a tree.
* Texture rendering: Loads texture images using the ‘loadTexture’ function. This function takes the path to an image file and loads it into a texture object.
Textures applied to 3D models using texture coordinates defined when rendering the cube. Uv sent to the Shadders. The Vertex Shader processes the vertex data and the Fragment Shader calculates the final color of each pixel on the 3D object’s surface
* Light rendering: Set the view matrix on the shader program using the ‘setUniformMat4’ function. A Light Cut Off Angle needed to be set. Two uniform values are used. Uniform value is used to set light color. A vec3 vale is passed which represents the color of the light in RGB format. 
For Light parameters, the parameters needed: light position, light focus, light direction. Finally the ‘SetUniformMat4’ function is used to combine light projection and view matrix and send them in the shader. 

**Controls**

